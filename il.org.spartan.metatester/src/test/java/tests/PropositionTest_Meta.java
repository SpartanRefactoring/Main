package tests;
import static org.assertj.core.api.Assertions.assertThat;
import static fluent.ly.azzert.*;
import static il.org.spartan.utils.Proposition.*;
import static il.org.spartan.utils.Proposition.not;
import static il.org.spartan.utils.Proposition.that;
import java.util.*;
import java.util.function.*;
import il.org.spartan.proposition.PropositionJavaNotation;
import metatester.MetaTester;
import org.junit.*;
import fluent.ly.*;
import il.org.spartan.utils.*;
import org.junit.runner.RunWith;
/** 
 * Tests class  {@link Proposition}
 * @author Yossi Gil {@code     Yossi.Gil@GMail.COM}
 * @since 2017-03-08 
 */
@SuppressWarnings("all") public class PropositionTest_Meta {
  private final PropositionJavaNotation javaReducer=new PropositionJavaNotation();
  Proposition condition;
  Proposition inner;
  Object object;
  BooleanSupplier supplier;
  private Proposition B1, T_OR_F_OR_X;
  private Proposition B2, T_AND_F_AND_X;
  private Proposition B3, NOT_F_AND_NOT_F_OR_X_OR_N_OR_T;
  private Proposition B4, T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T;
  private Proposition B5, B1_AND_B2;
  private Proposition B6, B2_AND_B1;
  private Proposition B7, B1_OR_B2;
  private Proposition B8, B2_OR_B1;
  private static boolean ignoreNext(){
    return true;
  }
  @Before public void setUp(){
    B1=T_OR_F_OR_X=Proposition.OR("T OR F OR X",T,F,X);
    B2=T_AND_F_AND_X=Proposition.AND("T AND F AND X",T,F,X);
    B3=NOT_F_AND_NOT_F_OR_X_OR_N_OR_T=not(F).and(not(F)).or(X).or(N,T);
    B4=T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T=Proposition.OR(T_OR_F_OR_X,NOT_F_AND_NOT_F_OR_X_OR_N_OR_T);
    B5=B1_AND_B2=B1.and(B2);
    B6=B2_AND_B1=B2.and(B1);
    B7=B1_OR_B2=B1.or(B2);
    B8=B2_OR_B1=B2.or(B1);
  }
  private boolean hasCycles(  final BooleanSupplier s){
    final Stack<BooleanSupplier> path=new Stack<>();
    path.add(s);
    final Queue<BooleanSupplier> todo=new LinkedList<>();
    do {
      final BooleanSupplier current=todo.isEmpty() ? path.pop() : todo.remove();
      if (path.contains(current))       return true;
      if (current instanceof Proposition.Some) {
        todo.addAll(((Proposition.Some)current).inner);
        continue;
      }
      if (current instanceof Proposition.Singleton)       path.push(((Proposition.Singleton)current).inner);
    }
 while (!path.isEmpty());
    return false;
  }
@Test(expected=AssertionError.class) public void a_meta0(){
X.getAsBoolean();}@Test public void aa_meta1(){
assertThat(object).isNotNull();
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta2(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta3(){
object=Proposition.T;
assertThat(object != null).isTrue();
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta4(){
object=Proposition.T;
assertThat(object).isNotNull();
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta5(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta6(){
object=Proposition.T;
object=Proposition.F;
assertThat(object != null).isTrue();
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta7(){
object=Proposition.T;
object=Proposition.F;
assertThat(object).isNotNull();
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta8(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta9(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
assertThat(object != null).isTrue();
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta10(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
assertThat(object).isNotNull();
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta11(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta12(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
assertThat(Proposition.T != null).isTrue();
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta13(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
assertThat(Proposition.T != null).isTrue();
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta14(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
assertThat(Proposition.F != null).isTrue();
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta15(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
assertThat(Proposition.T != null).isTrue();
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta16(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
assertThat(Proposition.F != null).isTrue();
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta17(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
assertThat(supplier).isNotNull();
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta18(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta19(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
assertThat(supplier != null).isTrue();
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta20(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
assertThat(supplier).isNotNull();
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta21(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta22(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
assertThat(supplier != null).isTrue();
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta23(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
assertThat(supplier).isNotNull();
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta24(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta25(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
assertThat(supplier != null).isTrue();
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta26(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
assertThat(supplier).isNotNull();
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta27(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta28(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
assertThat(supplier != null).isTrue();
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta29(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
assertThat(ignoreNext() || Proposition.T.getAsBoolean()).isTrue();
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta30(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
assertThat(ignoreNext() || Proposition.F.getAsBoolean()).isTrue();
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta31(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
assertThat(ignoreNext() || Proposition.T.getAsBoolean()).isTrue();
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta32(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
assertThat(ignoreNext() || Proposition.F.getAsBoolean()).isTrue();
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta33(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
assertThat(Proposition.T.getAsBoolean()).isTrue();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta34(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
assertThat(!Proposition.F.getAsBoolean()).isTrue();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta35(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
assertThat(Proposition.T.getAsBoolean()).isTrue();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta36(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
assertThat(!Proposition.F.getAsBoolean()).isTrue();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta37(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta38(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta39(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta40(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta41(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta42(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta43(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta44(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta45(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
assertThat(Proposition.that(Proposition.T) != null).isTrue();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta46(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
assertThat(Proposition.that(Proposition.F) != null).isTrue();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta47(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
assertThat(Proposition.that(Proposition.T) != null).isTrue();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta48(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
assertThat(Proposition.that(Proposition.F) != null).isTrue();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta49(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
assertThat(object).isNotNull();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta50(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta51(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
assertThat(object).isNotNull();
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta52(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta53(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
assertThat(object).isNotNull();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta54(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta55(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
assertThat(object).isNotNull();
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta56(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta57(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
assertThat(Proposition.that(Proposition.T) != null).isTrue();
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta58(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
assertThat(Proposition.that(Proposition.F) != null).isTrue();
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta59(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
assertThat(Proposition.that(Proposition.T) != null).isTrue();
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta60(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
assertThat(Proposition.that(Proposition.F) != null).isTrue();
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta61(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
assertThat(condition).isNotNull();
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta62(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta63(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
assertThat(condition).isNotNull();
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta64(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta65(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
assertThat(condition).isNotNull();
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta66(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta67(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
assertThat(condition).isNotNull();
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta68(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta69(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
assertThat(Proposition.that(() -> true).getAsBoolean()).isTrue();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta70(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
assertThat(Proposition.that(() -> condition != null).getAsBoolean()).isTrue();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta71(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
assertThat(!Proposition.that(() -> false).getAsBoolean()).isTrue();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta72(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
assertThat(Proposition.that(() -> hashCode() == hashCode()).getAsBoolean()).isTrue();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta73(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
assertThat(Proposition.that(Proposition.T).getAsBoolean()).isTrue();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta74(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
assertThat(!Proposition.that(Proposition.F).getAsBoolean()).isTrue();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta75(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
assertThat(Proposition.that(Proposition.T).getAsBoolean()).isTrue();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta76(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
assertThat(!Proposition.that(Proposition.F).getAsBoolean()).isTrue();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta77(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta78(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta79(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta80(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta81(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
assertThat(Proposition.AND(T,T).getAsBoolean()).isTrue();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta82(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
assertThat(supplier).isNotNull();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta83(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta84(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
assertThat(condition).isNotNull();
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta85(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta86(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
assertThat(inner).isNotNull();
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta87(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta88(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
assertThat(Proposition.AND(T,T).getAsBoolean()).isTrue();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta89(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
assertThat(!Proposition.AND(T,F).getAsBoolean()).isTrue();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta90(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
assertThat(!Proposition.AND(F,T).getAsBoolean()).isTrue();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta91(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
assertThat(!Proposition.AND(F,F).getAsBoolean()).isTrue();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta92(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
assertThat(Proposition.AND(T,T,T).getAsBoolean()).isTrue();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta93(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
assertThat(!Proposition.AND(T,F,T).getAsBoolean()).isTrue();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta94(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
assertThat(!Proposition.AND(F,T,T).getAsBoolean()).isTrue();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta95(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
assertThat(!Proposition.AND(F,F,T).getAsBoolean()).isTrue();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta96(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
assertThat(Proposition.AND(T,T,T).getAsBoolean()).isTrue();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta97(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
assertThat(!Proposition.AND(T,F,X).getAsBoolean()).isTrue();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta98(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
assertThat(!Proposition.AND(F,X,X).getAsBoolean()).isTrue();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta99(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
assertThat(!Proposition.AND(F,F,X).getAsBoolean()).isTrue();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta100(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta101(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta102(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta103(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta104(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
assertThat(Proposition.OR(T,T).getAsBoolean()).isTrue();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta105(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
assertThat(supplier).isNotNull();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta106(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta107(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
assertThat(condition).isNotNull();
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta108(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta109(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
assertThat(inner).isNotNull();
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta110(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta111(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
assertThat(Proposition.OR(T,T).getAsBoolean()).isTrue();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta112(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
assertThat(Proposition.OR(T,F).getAsBoolean()).isTrue();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta113(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
assertThat(Proposition.OR(F,T).getAsBoolean()).isTrue();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta114(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
assertThat(!Proposition.OR(F,F).getAsBoolean()).isTrue();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta115(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
assertThat(!Proposition.OR(F,F,F).getAsBoolean()).isTrue();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta116(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
assertThat(Proposition.OR(F,F,T).getAsBoolean()).isTrue();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta117(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
assertThat(Proposition.OR(F,T,F).getAsBoolean()).isTrue();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta118(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
assertThat(Proposition.OR(F,T,T).getAsBoolean()).isTrue();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta119(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
assertThat(Proposition.OR(T,F,F).getAsBoolean()).isTrue();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta120(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
assertThat(Proposition.OR(T,F,T).getAsBoolean()).isTrue();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta121(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
assertThat(Proposition.OR(T,T,F).getAsBoolean()).isTrue();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta122(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
assertThat(Proposition.OR(T,T,T).getAsBoolean()).isTrue();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta123(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
assertThat(Proposition.OR(F,T,X).getAsBoolean()).isTrue();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta124(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
assertThat(Proposition.OR(T,X,X).getAsBoolean()).isTrue();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta125(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
assertThat(T_OR_F_OR_X.getAsBoolean()).isTrue();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta126(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
assertThat(Proposition.OR(T,X,X).getAsBoolean()).isTrue();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta127(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
assertThat(Proposition.not(F).getAsBoolean()).isTrue();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta128(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
assertThat(!Proposition.not(T).getAsBoolean()).isTrue();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta129(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
assertThat(Proposition.not(F).and(not(F)).getAsBoolean()).isTrue();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta130(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
assertThat(!Proposition.not(F).and(not(T)).getAsBoolean()).isTrue();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta131(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
assertThat(Proposition.not(F).and(not(F)).or(T).getAsBoolean()).isTrue();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta132(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
assertThat(Proposition.not(F).and(not(F)).or(T).eval()).isTrue();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta133(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
assertThat(Proposition.not(F).and(not(F)).or(T).or(X).eval()).isTrue();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta134(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
assertThat(Proposition.not(F).and(not(F)).or(T).or(X,X).eval()).isTrue();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta135(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
assertThat(not(F).and(not(F)).getAsBoolean()).isTrue();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta136(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
assertThat(!not(F).and(not(T)).getAsBoolean()).isTrue();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta137(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
assertThat(not(F).and(not(F)).or(T).getAsBoolean()).isTrue();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta138(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
assertThat(not(F).and(not(F)).or(T).eval()).isTrue();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta139(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
assertThat(not(F).and(not(F)).or(T).or(X).eval()).isTrue();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta140(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta141(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
assertThat(or).isNotNull();
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta142(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
assertThat(or.eval()).isTrue();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta143(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
assertThat(Proposition.that(F).or(T).and(T).eval()).isTrue();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta144(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
assertThat(OR(F,T).and(T).eval()).isTrue();
OR(F,T).and(T).or(X).eval();}
@Test public void aa_meta145(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
assertThat(OR(F,T).and(T).or(X).eval()).isTrue();}
@Test public void aa_meta146(){
object=Proposition.T;
object=Proposition.F;
object=Proposition.N;
object=Proposition.X;
supplier=Proposition.T;
supplier=Proposition.F;
supplier=Proposition.T;
supplier=Proposition.F;
Proposition.T.getAsBoolean();
Proposition.T.getAsBoolean();
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
Proposition.that(Proposition.T);
Proposition.that(Proposition.F);
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
(Proposition.that(Proposition.T) + "").hashCode();
(Proposition.that(Proposition.F) + "").hashCode();
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
object=Proposition.that(Proposition.T);
object=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
condition=Proposition.that(Proposition.T);
condition=Proposition.that(Proposition.F);
Proposition.that(() -> true).getAsBoolean();
Proposition.that(() -> condition != null).getAsBoolean();
Proposition.that(() -> hashCode() == hashCode()).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.that(Proposition.T).getAsBoolean();
Proposition.AND(T,T);
Proposition.AND(T,T);
Proposition.AND(T,T,T);
Proposition.AND(T,T,T,T);
Proposition.AND(T,T).getAsBoolean();
supplier=AND(T,T);
condition=AND(T,T);
inner=AND(T,T);
Proposition.AND(T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.AND(T,T,T).getAsBoolean();
Proposition.OR(T,T);
Proposition.OR(T,T);
Proposition.OR(T,T,T);
Proposition.OR(T,T,T,T);
Proposition.OR(T,T).getAsBoolean();
supplier=OR(T,T);
condition=OR(T,T);
inner=OR(T,T);
Proposition.OR(T,T).getAsBoolean();
Proposition.OR(T,F).getAsBoolean();
Proposition.OR(F,T).getAsBoolean();
Proposition.OR(F,F,T).getAsBoolean();
Proposition.OR(F,T,F).getAsBoolean();
Proposition.OR(F,T,T).getAsBoolean();
Proposition.OR(T,F,F).getAsBoolean();
Proposition.OR(T,F,T).getAsBoolean();
Proposition.OR(T,T,F).getAsBoolean();
Proposition.OR(T,T,T).getAsBoolean();
Proposition.OR(F,T,X).getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
T_OR_F_OR_X.getAsBoolean();
Proposition.OR(T,X,X).getAsBoolean();
Proposition.not(F).getAsBoolean();
Proposition.not(F).and(not(F)).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).getAsBoolean();
Proposition.not(F).and(not(F)).or(T).eval();
Proposition.not(F).and(not(F)).or(T).or(X).eval();
Proposition.not(F).and(not(F)).or(T).or(X,X).eval();
not(F).and(not(F)).getAsBoolean();
not(F).and(not(F)).or(T).getAsBoolean();
not(F).and(not(F)).or(T).eval();
not(F).and(not(F)).or(T).or(X).eval();
final Proposition or=not(F).and(not(F)).or(T).or(X,X);
or.eval();
Proposition.that(F).or(T).and(T).eval();
OR(F,T).and(T).eval();
OR(F,T).and(T).or(X).eval();
assertThat(!OR(F,T).and(T).and(F).eval()).isTrue();}@Test public void b2_meta147(){
azzert.that(T_OR_F_OR_X + "",is("T OR F OR X"));
azzert.that(F.or(T).and(T).reduce(javaReducer),is("((F || T) && T)"));
azzert.that(F.and(X).or(T).reduce(javaReducer),is("((F && X) || T)"));
azzert.that(F.and("X1",X).or(T).reduce(javaReducer),is("((F && X1) || T)"));
azzert.that(F.or("X1",X).or(T).reduce(javaReducer),is("(F || X1 || T)"));}
@Test public void b2_meta148(){
azzert.that(T_OR_F_OR_X + "",is("T OR F OR X"));
assertThat(javaReducer).isNotNull();
azzert.that(F.or(T).and(T).reduce(javaReducer),is("((F || T) && T)"));
azzert.that(F.and(X).or(T).reduce(javaReducer),is("((F && X) || T)"));
azzert.that(F.and("X1",X).or(T).reduce(javaReducer),is("((F && X1) || T)"));
azzert.that(F.or("X1",X).or(T).reduce(javaReducer),is("(F || X1 || T)"));}
@Test public void b2_meta149(){
azzert.that(T_OR_F_OR_X + "",is("T OR F OR X"));
azzert.that(F.or(T).and(T).reduce(javaReducer),is("((F || T) && T)"));
azzert.that(F.and(X).or(T).reduce(javaReducer),is("((F && X) || T)"));
azzert.that(F.and("X1",X).or(T).reduce(javaReducer),is("((F && X1) || T)"));
azzert.that(F.or("X1",X).or(T).reduce(javaReducer),is("(F || X1 || T)"));}
@Test public void b2_meta150(){
azzert.that(T_OR_F_OR_X + "",is("T OR F OR X"));
azzert.that(F.or(T).and(T).reduce(javaReducer),is("((F || T) && T)"));
assertThat(javaReducer).isNotNull();
azzert.that(F.and(X).or(T).reduce(javaReducer),is("((F && X) || T)"));
azzert.that(F.and("X1",X).or(T).reduce(javaReducer),is("((F && X1) || T)"));
azzert.that(F.or("X1",X).or(T).reduce(javaReducer),is("(F || X1 || T)"));}
@Test public void b2_meta151(){
azzert.that(T_OR_F_OR_X + "",is("T OR F OR X"));
azzert.that(F.or(T).and(T).reduce(javaReducer),is("((F || T) && T)"));
azzert.that(F.and(X).or(T).reduce(javaReducer),is("((F && X) || T)"));
azzert.that(F.and("X1",X).or(T).reduce(javaReducer),is("((F && X1) || T)"));
azzert.that(F.or("X1",X).or(T).reduce(javaReducer),is("(F || X1 || T)"));}
@Test public void b2_meta152(){
azzert.that(T_OR_F_OR_X + "",is("T OR F OR X"));
azzert.that(F.or(T).and(T).reduce(javaReducer),is("((F || T) && T)"));
azzert.that(F.and(X).or(T).reduce(javaReducer),is("((F && X) || T)"));
assertThat(javaReducer).isNotNull();
azzert.that(F.and("X1",X).or(T).reduce(javaReducer),is("((F && X1) || T)"));
azzert.that(F.or("X1",X).or(T).reduce(javaReducer),is("(F || X1 || T)"));}
@Test public void b2_meta153(){
azzert.that(T_OR_F_OR_X + "",is("T OR F OR X"));
azzert.that(F.or(T).and(T).reduce(javaReducer),is("((F || T) && T)"));
azzert.that(F.and(X).or(T).reduce(javaReducer),is("((F && X) || T)"));
azzert.that(F.and("X1",X).or(T).reduce(javaReducer),is("((F && X1) || T)"));
azzert.that(F.or("X1",X).or(T).reduce(javaReducer),is("(F || X1 || T)"));}
@Test public void b2_meta154(){
azzert.that(T_OR_F_OR_X + "",is("T OR F OR X"));
azzert.that(F.or(T).and(T).reduce(javaReducer),is("((F || T) && T)"));
azzert.that(F.and(X).or(T).reduce(javaReducer),is("((F && X) || T)"));
azzert.that(F.and("X1",X).or(T).reduce(javaReducer),is("((F && X1) || T)"));
assertThat(javaReducer).isNotNull();
azzert.that(F.or("X1",X).or(T).reduce(javaReducer),is("(F || X1 || T)"));}
@Test public void b2_meta155(){
azzert.that(T_OR_F_OR_X + "",is("T OR F OR X"));
azzert.that(F.or(T).and(T).reduce(javaReducer),is("((F || T) && T)"));
azzert.that(F.and(X).or(T).reduce(javaReducer),is("((F && X) || T)"));
azzert.that(F.and("X1",X).or(T).reduce(javaReducer),is("((F && X1) || T)"));
azzert.that(F.or("X1",X).or(T).reduce(javaReducer),is("(F || X1 || T)"));}@Test public void b2a_meta156(){
assertThat(javaReducer).isNotNull();
azzert.that(OR(F,X,N).and(T).reduce(javaReducer),is("((F || X || N) && T)"));}
@Test public void b2a_meta157(){
azzert.that(OR(F,X,N).and(T).reduce(javaReducer),is("((F || X || N) && T)"));}@Test public void b3_meta158(){
assertThat(!hasCycles(T)).isTrue();}
@Test public void b3_meta159(){
assertThat(!hasCycles(X)).isTrue();}
@Test public void b3_meta160(){
assertThat(!hasCycles(F)).isTrue();}
@Test public void b3_meta161(){
assertThat(!hasCycles(N)).isTrue();}
@Test public void b3_meta162(){
assertThat(!hasCycles(T.and(F))).isTrue();}
@Test public void b3_meta163(){
assertThat(!hasCycles(F.and(T))).isTrue();}
@Test public void b3_meta164(){
assertThat(!hasCycles(T.and(T))).isTrue();}
@Test public void b3_meta165(){
assertThat(!hasCycles(T.or(T))).isTrue();}
@Test public void b3_meta166(){
assertThat(!hasCycles(T_AND_F_AND_X)).isTrue();}
@Test public void b3_meta167(){
assertThat(!hasCycles(T_OR_F_OR_X)).isTrue();}@Test public void b31_meta168(){
assertThat(!hasCycles(T.or(T))).isTrue();}@Test public void b32_meta169(){
assertThat(!hasCycles(T.and(T))).isTrue();}@Test public void b4_meta170(){
assertThat(javaReducer).isNotNull();
T.reduce(javaReducer);}
@Test public void b4_meta171(){
T.reduce(javaReducer);}@Test public void b5_meta172(){
assertThat(javaReducer).isNotNull();
F.and(F).reduce(javaReducer);}
@Test public void b5_meta173(){
F.and(F).reduce(javaReducer);}@Test public void b8_meta174(){
assertThat(javaReducer).isNotNull();
T.or(X).reduce(javaReducer);}
@Test public void b8_meta175(){
T.or(X).reduce(javaReducer);}@Test public void b9_meta176(){
assertThat(javaReducer).isNotNull();
azzert.that(X.reduce(javaReducer),instanceOf(String.class));
azzert.that(X.reduce(javaReducer),is("X"));
azzert.that(T.reduce(javaReducer),is("T"));
azzert.that(T.or(X).reduce(javaReducer),is("(T || X)"));}
@Test public void b9_meta177(){
azzert.that(X.reduce(javaReducer),instanceOf(String.class));
azzert.that(X.reduce(javaReducer),is("X"));
azzert.that(T.reduce(javaReducer),is("T"));
azzert.that(T.or(X).reduce(javaReducer),is("(T || X)"));}
@Test public void b9_meta178(){
azzert.that(X.reduce(javaReducer),instanceOf(String.class));
assertThat(javaReducer).isNotNull();
azzert.that(X.reduce(javaReducer),is("X"));
azzert.that(T.reduce(javaReducer),is("T"));
azzert.that(T.or(X).reduce(javaReducer),is("(T || X)"));}
@Test public void b9_meta179(){
azzert.that(X.reduce(javaReducer),instanceOf(String.class));
azzert.that(X.reduce(javaReducer),is("X"));
azzert.that(T.reduce(javaReducer),is("T"));
azzert.that(T.or(X).reduce(javaReducer),is("(T || X)"));}
@Test public void b9_meta180(){
azzert.that(X.reduce(javaReducer),instanceOf(String.class));
azzert.that(X.reduce(javaReducer),is("X"));
assertThat(javaReducer).isNotNull();
azzert.that(T.reduce(javaReducer),is("T"));
azzert.that(T.or(X).reduce(javaReducer),is("(T || X)"));}
@Test public void b9_meta181(){
azzert.that(X.reduce(javaReducer),instanceOf(String.class));
azzert.that(X.reduce(javaReducer),is("X"));
azzert.that(T.reduce(javaReducer),is("T"));
azzert.that(T.or(X).reduce(javaReducer),is("(T || X)"));}
@Test public void b9_meta182(){
azzert.that(X.reduce(javaReducer),instanceOf(String.class));
azzert.that(X.reduce(javaReducer),is("X"));
azzert.that(T.reduce(javaReducer),is("T"));
assertThat(javaReducer).isNotNull();
azzert.that(T.or(X).reduce(javaReducer),is("(T || X)"));}
@Test public void b9_meta183(){
azzert.that(X.reduce(javaReducer),instanceOf(String.class));
azzert.that(X.reduce(javaReducer),is("X"));
azzert.that(T.reduce(javaReducer),is("T"));
azzert.that(T.or(X).reduce(javaReducer),is("(T || X)"));}@Test public void b91_meta184(){
assertThat(javaReducer).isNotNull();
azzert.that(T.and(X).reduce(javaReducer),is("(T && X)"));}
@Test public void b91_meta185(){
azzert.that(T.and(X).reduce(javaReducer),is("(T && X)"));}@Test public void b92_meta186(){
assertThat(javaReducer).isNotNull();
azzert.that(not(T).reduce(javaReducer),is("!T"));}
@Test public void b92_meta187(){
azzert.that(not(T).reduce(javaReducer),is("!T"));}@Test public void b93_meta188(){
assertThat(javaReducer).isNotNull();
azzert.that(not(X).reduce(javaReducer),is("!X"));}
@Test public void b93_meta189(){
azzert.that(not(X).reduce(javaReducer),is("!X"));}@Test public void b94_meta190(){
assertThat(javaReducer).isNotNull();
azzert.that(not(N).reduce(javaReducer),is("!N"));}
@Test public void b94_meta191(){
azzert.that(not(N).reduce(javaReducer),is("!N"));}@Test public void b95_meta192(){
assertThat(javaReducer).isNotNull();
azzert.that(that(T).reduce(javaReducer),is("T"));}
@Test public void b95_meta193(){
azzert.that(that(T).reduce(javaReducer),is("T"));}@Test public void d_meta194(){
assertThat(javaReducer).isNotNull();
azzert.that(T_OR_F_OR_X.reduce(javaReducer),is("(T || F || X)"));}
@Test public void d_meta195(){
azzert.that(T_OR_F_OR_X.reduce(javaReducer),is("(T || F || X)"));}@Test public void d0_meta196(){
assertThat(javaReducer).isNotNull();
T.or(X,X).reduce(javaReducer);
azzert.that(T.or(X,X).reduce(javaReducer),is("(T || X || X)"));}
@Test public void d0_meta197(){
T.or(X,X).reduce(javaReducer);
azzert.that(T.or(X,X).reduce(javaReducer),is("(T || X || X)"));}
@Test public void d0_meta198(){
T.or(X,X).reduce(javaReducer);
assertThat(javaReducer).isNotNull();
azzert.that(T.or(X,X).reduce(javaReducer),is("(T || X || X)"));}
@Test public void d0_meta199(){
T.or(X,X).reduce(javaReducer);
azzert.that(T.or(X,X).reduce(javaReducer),is("(T || X || X)"));}@Test public void d1_meta200(){
azzert.that(T_OR_F_OR_X.reduce(new PropositionReducer<String>(new ReduceStringConcatenate()){
  @Override protected String map(  final BooleanSupplier ){
    return  + "";
  }
}
),is("TFX"));}@Test public void e_meta201(){
assertThat(javaReducer).isNotNull();
azzert.that(T_AND_F_AND_X.reduce(javaReducer),is("(T && F && X)"));}
@Test public void e_meta202(){
azzert.that(T_AND_F_AND_X.reduce(javaReducer),is("(T && F && X)"));}@Test public void f_meta203(){
assertThat(javaReducer).isNotNull();
azzert.that(NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("((!F && !F) || X || N || T)"));}
@Test public void f_meta204(){
azzert.that(NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("((!F && !F) || X || N || T)"));}@Test public void f0_meta205(){
azzert.that(T + "",is("T"));
azzert.that(F + "",is("F"));
azzert.that(N + "",is("N"));
azzert.that(X + "",is("X"));}
@Test public void f0_meta206(){
azzert.that(T + "",is("T"));
azzert.that(F + "",is("F"));
azzert.that(N + "",is("N"));
azzert.that(X + "",is("X"));}
@Test public void f0_meta207(){
azzert.that(T + "",is("T"));
azzert.that(F + "",is("F"));
azzert.that(N + "",is("N"));
azzert.that(X + "",is("X"));}
@Test public void f0_meta208(){
azzert.that(T + "",is("T"));
azzert.that(F + "",is("F"));
azzert.that(N + "",is("N"));
azzert.that(X + "",is("X"));}@Test public void g_meta209(){
assertThat(javaReducer).isNotNull();
azzert.that(T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));}
@Test public void g_meta210(){
azzert.that(T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));}@Test public void g1_meta211(){
assertThat(javaReducer).isNotNull();
azzert.that(Proposition.not(F).and(X).reduce(javaReducer),is("(!F && X)"));
azzert.that(Proposition.not(F).or(X).reduce(javaReducer),is("(!F || X)"));}
@Test public void g1_meta212(){
azzert.that(Proposition.not(F).and(X).reduce(javaReducer),is("(!F && X)"));
azzert.that(Proposition.not(F).or(X).reduce(javaReducer),is("(!F || X)"));}
@Test public void g1_meta213(){
azzert.that(Proposition.not(F).and(X).reduce(javaReducer),is("(!F && X)"));
assertThat(javaReducer).isNotNull();
azzert.that(Proposition.not(F).or(X).reduce(javaReducer),is("(!F || X)"));}
@Test public void g1_meta214(){
azzert.that(Proposition.not(F).and(X).reduce(javaReducer),is("(!F && X)"));
azzert.that(Proposition.not(F).or(X).reduce(javaReducer),is("(!F || X)"));}@Test public void g2_meta215(){
assertThat(javaReducer).isNotNull();
azzert.that(Proposition.that(F).and(X).reduce(javaReducer),is("(F && X)"));
azzert.that(Proposition.that(F).or(X).reduce(javaReducer),is("(F || X)"));}
@Test public void g2_meta216(){
azzert.that(Proposition.that(F).and(X).reduce(javaReducer),is("(F && X)"));
azzert.that(Proposition.that(F).or(X).reduce(javaReducer),is("(F || X)"));}
@Test public void g2_meta217(){
azzert.that(Proposition.that(F).and(X).reduce(javaReducer),is("(F && X)"));
assertThat(javaReducer).isNotNull();
azzert.that(Proposition.that(F).or(X).reduce(javaReducer),is("(F || X)"));}
@Test public void g2_meta218(){
azzert.that(Proposition.that(F).and(X).reduce(javaReducer),is("(F && X)"));
azzert.that(Proposition.that(F).or(X).reduce(javaReducer),is("(F || X)"));}@Test public void j_meta219(){
assertThat(javaReducer).isNotNull();
azzert.that(B3.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B4.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B5.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B1_AND_B2.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B6.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B2_AND_B1.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B7.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B1_OR_B2.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B8.reduce(javaReducer),is("((T && F && X) || T || F || X)"));
azzert.that(B2_OR_B1.reduce(javaReducer),is("((T && F && X) || T || F || X)"));}
@Test public void j_meta220(){
azzert.that(B3.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B4.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B5.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B1_AND_B2.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B6.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B2_AND_B1.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B7.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B1_OR_B2.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B8.reduce(javaReducer),is("((T && F && X) || T || F || X)"));
azzert.that(B2_OR_B1.reduce(javaReducer),is("((T && F && X) || T || F || X)"));}
@Test public void j_meta221(){
azzert.that(B3.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
assertThat(javaReducer).isNotNull();
azzert.that(NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B4.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B5.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B1_AND_B2.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B6.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B2_AND_B1.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B7.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B1_OR_B2.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B8.reduce(javaReducer),is("((T && F && X) || T || F || X)"));
azzert.that(B2_OR_B1.reduce(javaReducer),is("((T && F && X) || T || F || X)"));}
@Test public void j_meta222(){
azzert.that(B3.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B4.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B5.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B1_AND_B2.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B6.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B2_AND_B1.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B7.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B1_OR_B2.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B8.reduce(javaReducer),is("((T && F && X) || T || F || X)"));
azzert.that(B2_OR_B1.reduce(javaReducer),is("((T && F && X) || T || F || X)"));}
@Test public void j_meta223(){
azzert.that(B3.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
assertThat(javaReducer).isNotNull();
azzert.that(T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B4.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B5.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B1_AND_B2.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B6.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B2_AND_B1.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B7.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B1_OR_B2.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B8.reduce(javaReducer),is("((T && F && X) || T || F || X)"));
azzert.that(B2_OR_B1.reduce(javaReducer),is("((T && F && X) || T || F || X)"));}
@Test public void j_meta224(){
azzert.that(B3.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B4.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B5.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B1_AND_B2.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B6.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B2_AND_B1.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B7.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B1_OR_B2.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B8.reduce(javaReducer),is("((T && F && X) || T || F || X)"));
azzert.that(B2_OR_B1.reduce(javaReducer),is("((T && F && X) || T || F || X)"));}
@Test public void j_meta225(){
azzert.that(B3.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
assertThat(javaReducer).isNotNull();
azzert.that(B4.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B5.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B1_AND_B2.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B6.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B2_AND_B1.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B7.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B1_OR_B2.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B8.reduce(javaReducer),is("((T && F && X) || T || F || X)"));
azzert.that(B2_OR_B1.reduce(javaReducer),is("((T && F && X) || T || F || X)"));}
@Test public void j_meta226(){
azzert.that(B3.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B4.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B5.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B1_AND_B2.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B6.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B2_AND_B1.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B7.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B1_OR_B2.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B8.reduce(javaReducer),is("((T && F && X) || T || F || X)"));
azzert.that(B2_OR_B1.reduce(javaReducer),is("((T && F && X) || T || F || X)"));}
@Test public void j_meta227(){
azzert.that(B3.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B4.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
assertThat(javaReducer).isNotNull();
azzert.that(B5.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B1_AND_B2.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B6.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B2_AND_B1.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B7.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B1_OR_B2.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B8.reduce(javaReducer),is("((T && F && X) || T || F || X)"));
azzert.that(B2_OR_B1.reduce(javaReducer),is("((T && F && X) || T || F || X)"));}
@Test public void j_meta228(){
azzert.that(B3.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B4.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B5.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B1_AND_B2.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B6.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B2_AND_B1.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B7.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B1_OR_B2.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B8.reduce(javaReducer),is("((T && F && X) || T || F || X)"));
azzert.that(B2_OR_B1.reduce(javaReducer),is("((T && F && X) || T || F || X)"));}
@Test public void j_meta229(){
azzert.that(B3.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B4.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B5.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
assertThat(javaReducer).isNotNull();
azzert.that(B1_AND_B2.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B6.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B2_AND_B1.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B7.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B1_OR_B2.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B8.reduce(javaReducer),is("((T && F && X) || T || F || X)"));
azzert.that(B2_OR_B1.reduce(javaReducer),is("((T && F && X) || T || F || X)"));}
@Test public void j_meta230(){
azzert.that(B3.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B4.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B5.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B1_AND_B2.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B6.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B2_AND_B1.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B7.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B1_OR_B2.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B8.reduce(javaReducer),is("((T && F && X) || T || F || X)"));
azzert.that(B2_OR_B1.reduce(javaReducer),is("((T && F && X) || T || F || X)"));}
@Test public void j_meta231(){
azzert.that(B3.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B4.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B5.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B1_AND_B2.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
assertThat(javaReducer).isNotNull();
azzert.that(B6.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B2_AND_B1.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B7.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B1_OR_B2.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B8.reduce(javaReducer),is("((T && F && X) || T || F || X)"));
azzert.that(B2_OR_B1.reduce(javaReducer),is("((T && F && X) || T || F || X)"));}
@Test public void j_meta232(){
azzert.that(B3.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B4.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B5.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B1_AND_B2.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B6.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B2_AND_B1.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B7.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B1_OR_B2.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B8.reduce(javaReducer),is("((T && F && X) || T || F || X)"));
azzert.that(B2_OR_B1.reduce(javaReducer),is("((T && F && X) || T || F || X)"));}
@Test public void j_meta233(){
azzert.that(B3.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B4.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B5.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B1_AND_B2.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B6.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
assertThat(javaReducer).isNotNull();
azzert.that(B2_AND_B1.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B7.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B1_OR_B2.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B8.reduce(javaReducer),is("((T && F && X) || T || F || X)"));
azzert.that(B2_OR_B1.reduce(javaReducer),is("((T && F && X) || T || F || X)"));}
@Test public void j_meta234(){
azzert.that(B3.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B4.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B5.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B1_AND_B2.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B6.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B2_AND_B1.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B7.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B1_OR_B2.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B8.reduce(javaReducer),is("((T && F && X) || T || F || X)"));
azzert.that(B2_OR_B1.reduce(javaReducer),is("((T && F && X) || T || F || X)"));}
@Test public void j_meta235(){
azzert.that(B3.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B4.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B5.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B1_AND_B2.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B6.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B2_AND_B1.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
assertThat(javaReducer).isNotNull();
azzert.that(B7.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B1_OR_B2.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B8.reduce(javaReducer),is("((T && F && X) || T || F || X)"));
azzert.that(B2_OR_B1.reduce(javaReducer),is("((T && F && X) || T || F || X)"));}
@Test public void j_meta236(){
azzert.that(B3.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B4.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B5.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B1_AND_B2.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B6.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B2_AND_B1.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B7.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B1_OR_B2.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B8.reduce(javaReducer),is("((T && F && X) || T || F || X)"));
azzert.that(B2_OR_B1.reduce(javaReducer),is("((T && F && X) || T || F || X)"));}
@Test public void j_meta237(){
azzert.that(B3.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B4.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B5.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B1_AND_B2.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B6.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B2_AND_B1.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B7.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
assertThat(javaReducer).isNotNull();
azzert.that(B1_OR_B2.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B8.reduce(javaReducer),is("((T && F && X) || T || F || X)"));
azzert.that(B2_OR_B1.reduce(javaReducer),is("((T && F && X) || T || F || X)"));}
@Test public void j_meta238(){
azzert.that(B3.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B4.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B5.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B1_AND_B2.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B6.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B2_AND_B1.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B7.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B1_OR_B2.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B8.reduce(javaReducer),is("((T && F && X) || T || F || X)"));
azzert.that(B2_OR_B1.reduce(javaReducer),is("((T && F && X) || T || F || X)"));}
@Test public void j_meta239(){
azzert.that(B3.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B4.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B5.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B1_AND_B2.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B6.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B2_AND_B1.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B7.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B1_OR_B2.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
assertThat(javaReducer).isNotNull();
azzert.that(B8.reduce(javaReducer),is("((T && F && X) || T || F || X)"));
azzert.that(B2_OR_B1.reduce(javaReducer),is("((T && F && X) || T || F || X)"));}
@Test public void j_meta240(){
azzert.that(B3.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B4.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B5.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B1_AND_B2.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B6.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B2_AND_B1.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B7.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B1_OR_B2.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B8.reduce(javaReducer),is("((T && F && X) || T || F || X)"));
azzert.that(B2_OR_B1.reduce(javaReducer),is("((T && F && X) || T || F || X)"));}
@Test public void j_meta241(){
azzert.that(B3.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B4.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B5.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B1_AND_B2.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B6.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B2_AND_B1.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B7.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B1_OR_B2.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B8.reduce(javaReducer),is("((T && F && X) || T || F || X)"));
assertThat(javaReducer).isNotNull();
azzert.that(B2_OR_B1.reduce(javaReducer),is("((T && F && X) || T || F || X)"));}
@Test public void j_meta242(){
azzert.that(B3.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("((!F && !F) || X || N || T)"));
azzert.that(T_OR_F_OR_X_OR_NOT_F_AND_NOT_F_OR_X_OR_N_OR_T.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B4.reduce(javaReducer),is("(T || F || X || (!F && !F) || X || N || T)"));
azzert.that(B5.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B1_AND_B2.reduce(javaReducer),is("((T || F || X) && T && F && X)"));
azzert.that(B6.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B2_AND_B1.reduce(javaReducer),is("(T && F && X && (T || F || X))"));
azzert.that(B7.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B1_OR_B2.reduce(javaReducer),is("(T || F || X || (T && F && X))"));
azzert.that(B8.reduce(javaReducer),is("((T && F && X) || T || F || X)"));
azzert.that(B2_OR_B1.reduce(javaReducer),is("((T && F && X) || T || F || X)"));}@Test public void z_meta243(){
azzert.that(T_OR_F_OR_X.reduce(new PropositionReducer<String>(new ReduceStringConcatenate()){
  @Override protected String map(  @SuppressWarnings("unused") final BooleanSupplier __){
    return "";
  }
}
),is(""));}@Test public void z1_meta244(){
assertThat(T_OR_F_OR_X.eval()).isTrue();}
}
